<!DOCTYPE html>
<html lang="en">
<head>

<style>
  body, p, li, summary, button, pre, textarea { line-height: 1.7 !important; }
  #menuToggle {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 9999;
    width: 40px;
    height: 40px;
    background: #111;
    border: 2px solid #00ffcc;
    border-radius: 5px;
    cursor: pointer;
  }

  #menuToggle div {
    width: 60%;
    height: 4px;
    margin: 6px auto;
    background-color: #00ffcc;
  }

  #infoPanel {
    display: none;
    position: fixed;
    top: 0;
    right: 0;
    height: 100%;
    width: 90%;
    max-width: 400px;
    background: #111;
    color: #00ffcc;
    border-left: 3px solid #00ffcc;
    padding: 1rem;
    overflow-y: auto;
    z-index: 9998;
    font-size: 0.6rem;
  }

  #infoPanel h2 {
    font-size: 0.9rem;
    color: #ff00ff;
    margin-bottom: 0.5rem;
  }

  #infoPanel details {
    border: none;
    padding: 0;
    margin-top: 1rem;
  }

  #infoPanel summary {
    font-weight: bold;
    color: #00ffcc;
    cursor: pointer;
    font-size: 0.75rem;
  }
</style>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SB3 Route Planner</title>
  <style>
  body, p, li, summary, button, pre, textarea { line-height: 1.7 !important; }
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html { scroll-behavior: smooth; }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background-color: #111111; /* Solid dark background */
      color: #00ffcc;
      font-family: 'Press Start 2P', monospace;
      padding: 1rem;
      /* text-shadow: 0 0 2px #00ffcc; */ /* Removed text-shadow */
    }

    h1, h2 {
      font-size: 1rem;
      color: #ff00ff;
      margin: 1rem 0;
      text-align: center;
    }
    
    #routeInputs h3 {
        font-size: 0.7rem; color: #00ffcc; margin-top: 1rem; margin-bottom: 0.25rem; text-align: left;
    }

    input[type="text"],
    input[type="number"],
    input[type="file"], button, a {
      width: 100%;
      box-sizing: border-box;
      background-color: #1f1f1f;
      border: 2px solid #00ffcc;
      color: #00ffcc;
      font-family: 'Press Start 2P', monospace;
      padding: 0.5rem; 
      font-size: 0.65rem; 
      margin-top: 0.5rem; 
      margin-bottom: 0.5rem; 
      border-radius: 6px;
      cursor: pointer;
      display: block; 
      text-decoration: none;
      text-align: center;
    }
    input[type="number"]#placesNumStops { /* More specific selector */
        width: 80px; /* Smaller width for number input */
        display: inline-block; 
        vertical-align: middle;
        margin-left: 0.5rem;
    }
    label[for="placesNumStops"] {
        font-size: 0.65rem;
        vertical-align: middle;
    }


    #mapsLink a { 
      display: block;
      margin-top: 0.5rem;
      background: #00ffcc;
      color: #000;
      font-weight: bold;
      text-shadow: none;
    }

    #mapsLink a:hover, button:hover {
      background-color: #00cccc;
      color: black;
    }

    #status, #routeInputStatus {
      margin-top: 10px;
      color: #00ffcc;
      font-size: 0.75rem;
      text-align: center;
      min-height: 1em; 
    }
    #routeInputStatus {
        font-size: 0.6rem;
    }


    @media (max-width: 600px) {
      #map { height: 300px; }
    }
    #map {
      height: 500px;
      width: 100%;
      margin-top: 1rem;
      border: 3px dotted #ff00ff;
    }

    ol {
      margin-top: 1rem;
      padding-left: 1rem; 
      background-color: rgba(255, 255, 255, 0.05);
      border-left: 4px solid #00ffcc;
    }

    li {
      margin-bottom: 0.5rem;
      font-size: 0.6rem;
    }
  </style>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDMFmXm-gGi7bO7Bq5YD0SaB0fvk3ZrS_4&libraries=places&callback=initMapAsync" async defer></script>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics-compat.js"></script>
</head>
<body>

  <h1>SB3 Route Planner</h1>

  <div id="routeInputs" style="margin-bottom: 1rem; padding: 1rem; border: 2px solid #00ffcc; border-radius: 6px;">
    <h2 style="font-size: 0.8rem; color: #00ffcc; margin-bottom: 0.5rem;">Plan Your Route</h2>
    <input type="text" id="startLocationInput" placeholder="Enter Start Location">
    <input type="text" id="endLocationInput" placeholder="Enter End Location">
    
    <h3 style="font-size: 0.7rem; color: #00ffcc; margin-top: 1rem; margin-bottom: 0.25rem;">Location Type</h3>
    <input type="text" id="placesSearchTerm" placeholder="e.g., smoke shops, Head Hunters, Delta 8 Denton">
    <div>
      <label for="placesNumStops" style="font-size:0.65rem; margin-right:0.5rem;">Number of stops to find in start location's city:</label>
      <input type="number" id="placesNumStops" value="1" min="1" title="Number of stops of this type to find">
    </div>
    
    <button onclick="planRouteFromInputs()">Plan Route</button>
    <button onclick="clearSavedRoute()" style="margin-top: 0.5rem; background-color: #555;">Clear Saved Route & Current</button>
    <div id="routeInputStatus"></div>
  </div>
    
<!-- Route List Output Section -->
<div id="routeOutput" style="display:none;"></div>
    
  <a id="mapsLink" href="#" target="_blank">Open Optimized Route in Google Maps</a>
  
<!-- Google Maps Display -->
<div id="map"></div>

<!-- Hamburger Menu Icon -->
<div id="menuToggle" onclick="toggleMenu()">
  <div></div>
  <div></div>
  <div></div>
</div>

<!-- Sidebar Panel: Settings, Instructions, Prompts -->
<div id="infoPanel">
  <details id="authSection" style="margin-top:1rem;">
    <summary>Login / Register</summary>
    <div id="authContainer" style="margin-top:0.5rem;">
      <div id="userLoggedIn" style="display:none;">
        <p>Logged in as: <span id="userEmailDisplay"></span></p>
        <button onclick="signOutUser()">Sign Out</button>
      </div>
      <div id="userLoggedOut">
        <input type="email" id="emailInput" placeholder="Enter your email" style="margin-bottom: 0.5rem;">
        <input type="password" id="passwordInput" placeholder="Enter your password" style="margin-bottom: 0.5rem;">
        <button onclick="handleEmailLogin()">Login / Register with Email</button>
        <p id="authStatus" style="font-size:0.6rem; margin-top:0.5rem;"></p>
      </div>
    </div>
  </details>

  <details style="margin-top:1rem;">
    <summary>How to Use This Tool</summary>
    <div style="margin-top:0.5rem;">
      <p>This tool helps you plan routes using Google Maps.</p>
      <ol style="padding-left: 1.2rem; margin-top: 1rem;">
        <li>Enter your start and end locations using the autocomplete inputs.</li>
        <li>Optionally, under "Location Type", enter a type of place (e.g., "smoke shops", "Head Hunters") and specify how many such stops you'd like to find.</li>
        <li>These intermediate stops will be searched for primarily within the city of your start location. If your search term for location types includes "in [Specific City]", that city will be prioritized for the search.</li>
        <li>Click "Plan Route".</li>
        <li>The route will appear on the map and as a list of stops below.</li>
        <li>Review your route: Uncheck any stop to remove it. The map and route links update automatically.</li>
        <li>Click "Open Route Part X" buttons to open segments in Google Maps (mobile-friendly).</li>
      </ol>
    </div>
  </details>
</div>

<script>
    let directionsService, directionsRenderer, currentLocations, map;

    function initMapAsync() {
      initMap();
      loadSavedRoute(); // Attempt to load saved route after map is ready
    }

    function initMap() {
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        console.error("Google Maps API not loaded yet. initMap called prematurely.");
        return;
      }
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: { lat: 33.5779, lng: -101.8552 } 
      });
      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer();
      directionsRenderer.setMap(map);

      const autocompleteOptions = {
        fields: ["formatted_address", "geometry", "name", "place_id"], // geometry is useful for Autocomplete getPlace()
        strictBounds: false,
      };

      const startInput = document.getElementById('startLocationInput');
      const endInput = document.getElementById('endLocationInput');
      // const placesSearchTermInput = document.getElementById('placesSearchTerm'); // Autocomplete removed for this field
      
      if (startInput) new google.maps.places.Autocomplete(startInput, autocompleteOptions);
      if (endInput) new google.maps.places.Autocomplete(endInput, autocompleteOptions);
      // if (placesSearchTermInput) new google.maps.places.Autocomplete(placesSearchTermInput, {types: ['establishment', 'geocode']}); // Removed Autocomplete
    }

    async function planRouteFromInputs() {
      const startInput = document.getElementById('startLocationInput');
      const endInput = document.getElementById('endLocationInput');
      const statusDiv = document.getElementById('routeInputStatus');

      if (!startInput || !endInput || !statusDiv) {
          console.error("One or more essential UI elements for route input are missing.");
          return;
      }

      const startAddress = startInput.value.trim();
      const endAddress = endInput.value.trim();
      
      if (!startAddress || !endAddress) {
        statusDiv.innerText = "Please enter both start and end locations.";
        return;
      }
      statusDiv.innerText = "Planning route...";
      
      const searchTerm = document.getElementById('placesSearchTerm').value.trim();
      // const searchRadiusRaw = document.getElementById('placesSearchRadius').value.trim(); // Radius input removed
      const numStops = parseInt(document.getElementById('placesNumStops').value, 10) || 0;

      let intermediateStops = [];
      
      if (searchTerm && numStops > 0) {
        if (!google || !google.maps || !google.maps.places || !google.maps.places.Place) {
            statusDiv.innerText = "Google Places API not ready. Please wait or refresh.";
            console.error("Google Maps Places API (new) not initialized or available.");
            return;
        }
        statusDiv.innerText = "Searching for intermediate stops...";

        let effectiveSearchTerm = searchTerm;
        const cityFromStartAddress = extractCityFromAddress(startAddress);

        if (cityFromStartAddress) {
            // If search term already contains "in city", respect that. Otherwise, append start city.
            if (!searchTerm.toLowerCase().includes(" in ")) {
                effectiveSearchTerm = `${searchTerm} in ${cityFromStartAddress}`;
            }
        }
        // If no city could be extracted, effectiveSearchTerm remains the original searchTerm.
        // Results might be broad, or user needs to be specific in searchTerm (e.g. "Target in Austin")

        const searchRequest = {
          textQuery: effectiveSearchTerm,
          fields: ['displayName', 'formattedAddress', 'location'],
          maxResultCount: numStops,
          // No locationBias is applied here to keep it simple and rely on textQuery's location part.
        };
        console.log("Places API Search Request:", searchRequest);

        try {
          const { places } = await google.maps.places.Place.searchByText(searchRequest);
          if (places && places.length > 0) {
            places.forEach((place, i) => {
              intermediateStops.push({
                name: place.displayName || `${searchTerm} ${i + 1}`, // Use original searchTerm for naming
                address: place.formattedAddress || (place.location ? place.location.toString() : 'Address not found')
              });
            });
          } else {
            statusDiv.innerText = `No results found for "${effectiveSearchTerm}". Route will be planned without these stops.`;
          }
        } catch (error) {
          console.error("Error during Places search:", error);
          statusDiv.innerText = "Error searching for places. Route will be planned without these stops.";
        }
      }

      const locations = [
        { name: "Start", address: startAddress },
        ...intermediateStops,
        { name: "End", address: endAddress }
      ];
      currentLocations = locations;
      localStorage.setItem('sb3RoutePlanner_lastRoute', JSON.stringify(locations)); // Save to localStorage
      displayRoute(locations);
      planRoute(locations);
      
      // Clear status only if it wasn't an error/no results message for intermediate stops
      if (statusDiv.innerText === "Planning route..." || statusDiv.innerText === "Searching for intermediate stops...") {
         statusDiv.innerText = "";
      }
    }

    function loadSavedRoute() {
      const savedRouteData = localStorage.getItem('sb3RoutePlanner_lastRoute');
      const statusDiv = document.getElementById('routeInputStatus');
      if (savedRouteData) {
        try {
          const locations = JSON.parse(savedRouteData);
          if (locations && locations.length > 0) {
            currentLocations = locations;
            displayRoute(locations);
            planRoute(locations);
            if (statusDiv) statusDiv.innerText = "Loaded saved route.";
            setTimeout(() => { if (statusDiv && statusDiv.innerText === "Loaded saved route.") statusDiv.innerText = ""; }, 3000);
          }
        } catch (e) {
          console.error("Error parsing saved route data:", e);
          localStorage.removeItem('sb3RoutePlanner_lastRoute'); // Clear corrupted data
        }
      }
    }

    function clearSavedRoute() {
      localStorage.removeItem('sb3RoutePlanner_lastRoute');
      currentLocations = [];
      if (directionsRenderer) {
        directionsRenderer.setDirections({ routes: [] });
      }
      const routeOutput = document.getElementById('routeOutput');
      if (routeOutput) {
        routeOutput.innerHTML = '';
        routeOutput.style.display = 'none';
      }
      const mapsLink = document.getElementById('mapsLink');
      if (mapsLink) {
        mapsLink.innerHTML = '';
        mapsLink.style.display = 'none';
      }
      const statusDiv = document.getElementById('routeInputStatus');
      if (statusDiv) statusDiv.innerText = "Saved route cleared.";
      const mainStatus = document.getElementById('status');
      if(mainStatus) mainStatus.innerText = "";
       setTimeout(() => { if (statusDiv && statusDiv.innerText === "Saved route cleared.") statusDiv.innerText = ""; }, 3000);
    }
    
    function extractCityFromAddress(fullAddress) {
        if (!fullAddress) return null;
        const parts = fullAddress.split(',');
        if (parts.length >= 3) { // Expects something like "Street, City, State ZIP"
            let city = parts[parts.length - 2].trim(); // Part before state/zip
            let stateZipPart = parts[parts.length - 1].trim();
            let state = stateZipPart.split(/\s+/)[0]; // Get first word (state)
             // Basic check for two-letter state code
            if (/^[A-Za-z]{2}$/.test(state)) {
                 return `${city}, ${state}`;
            }
            return city; // Fallback to just city part if state is not clear
        } else if (parts.length === 2) { // Might be "City, State"
            return parts[0].trim(); // Assume first part is city
        }
        return null; // Could not reliably extract city
    }

    function processPastedJson(jsonString) {
      let rawJson;
      if (typeof jsonString === 'string') {
        rawJson = jsonString;
      } else {
        console.warn("processPastedJson called without string and jsonInput element is removed.");
        return; 
      }
      try {
        const locations = JSON.parse(rawJson);
        currentLocations = locations; 
        displayRoute(locations);
        planRoute(locations);
        document.getElementById("status").innerText = "Route loaded successfully!";
      } catch (err) {
        document.getElementById("status").innerText = "Invalid JSON format.";
        console.error("Error processing JSON:", err, "Raw JSON:", rawJson);
      }
    }
    
    function displayRoute(locations) {
      const output = document.getElementById('routeOutput');
      if (!output) return;
      output.style.display = 'block';
      output.innerHTML = '<h2>Route Stops:</h2>'; 
      const list = document.createElement('ol');
      locations.forEach((location, index) => { 
        const item = document.createElement("li");
        item.style.display = "flex";
        item.style.alignItems = "flex-start"; 
        item.style.gap = "0.5rem";
        item.style.marginBottom = "0.5rem"; 

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true;
        checkbox.id = `loc_checkbox_${index}`; 
        checkbox.style.marginTop = "0.2em"; 

        const label = document.createElement("span");
        label.textContent = `${location.name}: ${location.address}`;
        label.style.lineHeight = "1.5"; 

        checkbox.addEventListener("change", updateFromCheckboxes);
        
        item.appendChild(checkbox);
        item.appendChild(label);
    
        list.appendChild(item);
      });
      output.appendChild(list);
    }
    
    function planRoute(locations) {
      const statusElem = document.getElementById("status");
      if (!google || !google.maps || !directionsService || !directionsRenderer) {
        console.warn("Google Maps API components not ready for planRoute.");
        if (statusElem) statusElem.innerText = "Map service not ready. Please wait a moment and try again.";
        return;
      }
      if (!locations || locations.length < 2) {
        if (statusElem) statusElem.innerText = "Need at least two locations to plan a route.";
        if(directionsRenderer) directionsRenderer.setDirections({routes: []}); 
        document.getElementById("mapsLink").style.display = "none";
        return;
      }

      const origin = locations[0].address.trim();
      const destination = locations[locations.length - 1].address.trim();
      const waypoints = locations.slice(1, -1).map(loc => ({
        location: loc.address.trim(),
        stopover: true
      }));

      directionsService.route({
        origin,
        destination,
        waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: true 
      }, (response, status) => {
        if (status === 'OK') {
          directionsRenderer.setDirections(response);
          
          const optimizedRoutePoints = [];
          optimizedRoutePoints.push({ name: locations[0].name, address: response.routes[0].legs[0].start_address }); 

          response.routes[0].legs.forEach((leg, legIndex) => {
            if (legIndex < response.routes[0].legs.length -1) {
                 const waypointOrderIndex = response.routes[0].waypoint_order[legIndex];
                 optimizedRoutePoints.push({
                    name: locations[waypointOrderIndex + 1].name, 
                    address: leg.end_address
                 });
            }
          });
          optimizedRoutePoints.push({ name: locations[locations.length-1].name, address: response.routes[0].legs[response.routes[0].legs.length - 1].end_address}); 


          const chunks = [];
          for (let i = 0; i < optimizedRoutePoints.length -1; i += (8 + 1) ) { 
            const chunkEndIndex = Math.min(i + (8+1) , optimizedRoutePoints.length - 1);
            const chunkOrigin = optimizedRoutePoints[i].address;
            const chunkDest = optimizedRoutePoints[chunkEndIndex].address;
            const chunkWaypoints = optimizedRoutePoints.slice(i + 1, chunkEndIndex).map(loc => loc.address);
            
            chunks.push({ origin: chunkOrigin, destination: chunkDest, waypoints: chunkWaypoints });
          }

          const container = document.getElementById("mapsLink");
          container.innerHTML = ""; 
          if (chunks.length > 0) {
            chunks.forEach((chunk, idx) => {
              const chunkUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(chunk.origin)}&destination=${encodeURIComponent(chunk.destination)}&travelmode=driving&waypoints=${chunk.waypoints.map(encodeURIComponent).join('|')}`;
              const btn = document.createElement("a");
              btn.href = chunkUrl;
              btn.target = "_blank";
              btn.textContent = `Open Route Part ${idx + 1}`;
              container.appendChild(btn);
            });
            container.style.display = 'block';
          } else {
             container.style.display = 'none';
          }
          if (statusElem) statusElem.innerText = "Route planned successfully.";
        } else {
          if (statusElem) statusElem.innerText = 'Directions request failed due to ' + status;
          console.error('Directions request failed due to ' + status, response);
        }
      });
    }

    function updateFromCheckboxes() {
      const selectedLocations = [];
      const displayedItems = document.querySelectorAll('#routeOutput ol li');
      
      displayedItems.forEach((li, index) => {
        const checkbox = li.querySelector('input[type="checkbox"]');
        if (checkbox && checkbox.checked && currentLocations && currentLocations[index]) { // Added check for currentLocations
          selectedLocations.push(currentLocations[index]);
        }
      });

      if (selectedLocations.length >= 2) {
        planRoute(selectedLocations);
      } else {
        document.getElementById("mapsLink").style.display = "none";
        if (directionsRenderer) directionsRenderer.setDirections({routes: []}); 
        const statusElem = document.getElementById("status");
        if (statusElem) statusElem.innerText = "Select at least two locations for a route.";
      }
    }
  
    function toggleLocationList() {
      // This function is currently orphaned as its button was removed.
      const routeBlock = document.getElementById("routeOutput");
      if (routeBlock) routeBlock.style.display = routeBlock.style.display === 'none' ? 'block' : 'none';
    }

    function toggleMenu() {
      const panel = document.getElementById("infoPanel");
      panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
    }

    // Firebase Initialization and Auth Logic
    const firebaseConfig = {
      apiKey: "AIzaSyAm-QMDte5ytPN7Z8Cz7VaDe7hUVGsTE-8",
      authDomain: "sb3calltool.firebaseapp.com",
      databaseURL: "https://sb3calltool-default-rtdb.firebaseio.com",
      projectId: "sb3calltool",
      storageBucket: "sb3calltool.appspot.com", // Corrected: .appspot.com
      messagingSenderId: "834566220861",
      appId: "1:834566220861:web:e7e14abeff6558e24b0e54",
      measurementId: "G-7C1FRV4S69"
    };

    // Initialize Firebase
    const firebaseApp = firebase.initializeApp(firebaseConfig); // Using compat version
    const auth = firebase.auth(); // Using compat version for auth
    const analytics = firebase.analytics(); // Using compat version for analytics

    const userLoggedInDiv = document.getElementById('userLoggedIn');
    const userLoggedOutDiv = document.getElementById('userLoggedOut');
    const userEmailDisplay = document.getElementById('userEmailDisplay');
    const authStatusP = document.getElementById('authStatus');
    const authSectionSummary = document.querySelector('#authSection summary');

    function updateUIAfterAuthChange(user) {
        if (user) {
            // User is signed in
            if (userLoggedInDiv) userLoggedInDiv.style.display = 'block';
            if (userLoggedOutDiv) userLoggedOutDiv.style.display = 'none';
            if (userEmailDisplay) userEmailDisplay.textContent = user.email;
            // authStatusP is part of userLoggedOutDiv, so clear it or set login success briefly
            // if (authStatusP) authStatusP.textContent = 'Successfully logged in.'; // This might flicker
            if (authSectionSummary) authSectionSummary.textContent = 'Account (' + user.email.split('@')[0] + ')';
            console.log("User logged in:", user.uid, user.email);
        } else {
            // User is signed out
            if (userLoggedInDiv) userLoggedInDiv.style.display = 'none';
            if (userLoggedOutDiv) userLoggedOutDiv.style.display = 'block';
            if (userEmailDisplay) userEmailDisplay.textContent = '';
            if (authStatusP) authStatusP.textContent = 'Signed out.'; // Indicate signed out
            if (authSectionSummary) authSectionSummary.textContent = 'Login / Register';
            console.log("User logged out.");
        }
    }

    auth.onAuthStateChanged(user => {
        updateUIAfterAuthChange(user);
    });

    async function handleEmailLogin() {
      const emailInput = document.getElementById('emailInput');
      const passwordInput = document.getElementById('passwordInput');
      const email = emailInput.value;
      const password = passwordInput.value;

      if (!email || !password) {
        if (authStatusP) authStatusP.textContent = "Please enter email and password.";
        return;
      }
      if (authStatusP) authStatusP.textContent = "Processing...";

      try {
        await auth.signInWithEmailAndPassword(email, password);
        if (authStatusP) authStatusP.textContent = "Login successful!"; // Will be updated by onAuthStateChanged too
        // UI update will be handled by onAuthStateChanged
      } catch (error) {
        if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password') {
          // Try to register
          if (authStatusP) authStatusP.textContent = "User not found or wrong password. Attempting to register...";
          try {
            await auth.createUserWithEmailAndPassword(email, password);
            if (authStatusP) authStatusP.textContent = "Registration successful! Logging in...";
            // UI update will be handled by onAuthStateChanged
          } catch (registerError) {
            console.error("Registration error:", registerError);
            if (authStatusP) authStatusP.textContent = "Registration failed: " + registerError.message;
          }
        } else {
          console.error("Login error:", error);
          if (authStatusP) authStatusP.textContent = "Login failed: " + error.message;
        }
      }
    }

    function signOutUser() {
      if (authStatusP) authStatusP.textContent = "Signing out...";
      auth.signOut().then(() => {
        // Explicitly update UI here to prevent flicker, onAuthStateChanged will also fire
        updateUIAfterAuthChange(null); 
        if (authStatusP) authStatusP.textContent = "You have been signed out.";
      }).catch((error) => {
        console.error("Sign out error:", error);
        if (authStatusP) authStatusP.textContent = "Sign out failed: " + error.message;
      });
    }

</script>

</body>
</html>
